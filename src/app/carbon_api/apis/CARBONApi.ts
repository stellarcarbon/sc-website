/* tslint:disable */
/* eslint-disable */
/**
 * Stellarcarbon API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.4.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CarbonAmount,
  HTTPValidationError,
  MemoType,
  PaymentAsset,
  QuoteResponse,
  SinkingResponse,
} from '../models/index';
import {
    CarbonAmountFromJSON,
    CarbonAmountToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    MemoTypeFromJSON,
    MemoTypeToJSON,
    PaymentAssetFromJSON,
    PaymentAssetToJSON,
    QuoteResponseFromJSON,
    QuoteResponseToJSON,
    SinkingResponseFromJSON,
    SinkingResponseToJSON,
} from '../models/index';

export interface BuildSinkCarbonXdrSinkCarbonXdrPostRequest {
    funder: string;
    recipient?: string | null;
    carbonAmount?: CarbonAmount;
    paymentAsset?: PaymentAsset | null;
    vcsProjectId?: string;
    memoType?: MemoType | null;
    memoValue?: string | null;
    email?: string | null;
}

export interface GetCarbonQuoteCarbonQuoteGetRequest {
    carbonAmount?: CarbonAmount;
}

/**
 * 
 */
export class CARBONApi extends runtime.BaseAPI {

    /**
     * An offset is done by atomically swapping CARBON for CarbonSINK. This endpoint can be used to build the XDR for such a sinking transaction.  - *funder*: public key of the account that pays for the transaction - *recipient*: public key of the account that will receive CarbonSINK (default: funder) - *carbon_amount*: the amount of CARBON to sink - *payment_asset*: the preferred asset to pay with when the funder does not have a sufficient CARBON balance - *vcs_project_id*: carbon project from which credits will be retired - *memo_type*: the kind of memo that will be attached to the transaction - *memo_value*: description of the reason for offsetting - *email*: email address that will receive the Verra certificate (also supports `Your Name <account@domain.xyz>` format)  If the funder does not have a sufficient balance of CARBON, a path payment will be used to purchase the exact amount of CARBON to be retired. The most favorable rate will be selected from the possible paths. The USDC value of this payment is included in the response for convenience, but it is advisable to always check the generated XDR before signing and submitting it to the network.
     * Build the XDR for a new CARBON sinking transaction.
     */
    async buildSinkCarbonXdrSinkCarbonXdrPostRaw(requestParameters: BuildSinkCarbonXdrSinkCarbonXdrPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SinkingResponse>> {
        if (requestParameters.funder === null || requestParameters.funder === undefined) {
            throw new runtime.RequiredError('funder','Required parameter requestParameters.funder was null or undefined when calling buildSinkCarbonXdrSinkCarbonXdrPost.');
        }

        const queryParameters: any = {};

        if (requestParameters.funder !== undefined) {
            queryParameters['funder'] = requestParameters.funder;
        }

        if (requestParameters.recipient !== undefined) {
            queryParameters['recipient'] = requestParameters.recipient;
        }

        if (requestParameters.carbonAmount !== undefined) {
            queryParameters['carbon_amount'] = requestParameters.carbonAmount;
        }

        if (requestParameters.paymentAsset !== undefined) {
            queryParameters['payment_asset'] = requestParameters.paymentAsset;
        }

        if (requestParameters.vcsProjectId !== undefined) {
            queryParameters['vcs_project_id'] = requestParameters.vcsProjectId;
        }

        if (requestParameters.memoType !== undefined) {
            queryParameters['memo_type'] = requestParameters.memoType;
        }

        if (requestParameters.memoValue !== undefined) {
            queryParameters['memo_value'] = requestParameters.memoValue;
        }

        if (requestParameters.email !== undefined) {
            queryParameters['email'] = requestParameters.email;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sink-carbon/xdr`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SinkingResponseFromJSON(jsonValue));
    }

    /**
     * An offset is done by atomically swapping CARBON for CarbonSINK. This endpoint can be used to build the XDR for such a sinking transaction.  - *funder*: public key of the account that pays for the transaction - *recipient*: public key of the account that will receive CarbonSINK (default: funder) - *carbon_amount*: the amount of CARBON to sink - *payment_asset*: the preferred asset to pay with when the funder does not have a sufficient CARBON balance - *vcs_project_id*: carbon project from which credits will be retired - *memo_type*: the kind of memo that will be attached to the transaction - *memo_value*: description of the reason for offsetting - *email*: email address that will receive the Verra certificate (also supports `Your Name <account@domain.xyz>` format)  If the funder does not have a sufficient balance of CARBON, a path payment will be used to purchase the exact amount of CARBON to be retired. The most favorable rate will be selected from the possible paths. The USDC value of this payment is included in the response for convenience, but it is advisable to always check the generated XDR before signing and submitting it to the network.
     * Build the XDR for a new CARBON sinking transaction.
     */
    async buildSinkCarbonXdrSinkCarbonXdrPost(requestParameters: BuildSinkCarbonXdrSinkCarbonXdrPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SinkingResponse> {
        const response = await this.buildSinkCarbonXdrSinkCarbonXdrPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Request a price quote for any amount of CARBON.  The response includes the total cost of the requested amount, as well as the average price per CARBON. Both are denominated in USD.  This quote is non-binding and does not take into account the amount of CARBON that we are currently able to provide from our pool.
     * Get a quote of the current CARBON price in USD.
     */
    async getCarbonQuoteCarbonQuoteGetRaw(requestParameters: GetCarbonQuoteCarbonQuoteGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuoteResponse>> {
        const queryParameters: any = {};

        if (requestParameters.carbonAmount !== undefined) {
            queryParameters['carbon_amount'] = requestParameters.carbonAmount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/carbon-quote`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuoteResponseFromJSON(jsonValue));
    }

    /**
     * Request a price quote for any amount of CARBON.  The response includes the total cost of the requested amount, as well as the average price per CARBON. Both are denominated in USD.  This quote is non-binding and does not take into account the amount of CARBON that we are currently able to provide from our pool.
     * Get a quote of the current CARBON price in USD.
     */
    async getCarbonQuoteCarbonQuoteGet(requestParameters: GetCarbonQuoteCarbonQuoteGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuoteResponse> {
        const response = await this.getCarbonQuoteCarbonQuoteGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
